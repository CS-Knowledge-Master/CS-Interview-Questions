# 트랜잭션 격리 수준에 대해 설명해주세요.

## 답변

```
트랜잭션 격리수준이란 여러 트랜잭션이 동시에 처리되는 과정에서 특정 트랜잭션이 다른 트랜잭션을 변경하거나 조회하는 데이터를 볼 수 있게 허용할지에 대한 여부를 결정하는 단계라고 불수있습니다.
수준으로는 엄격한 격리순으로 SERIALIZABLE,REPEATABLE READ,READ COMMITED,READ UNCOMMITED가 있습니다.
```

## 내용 정리

- 트랜잭션 격리수준(Isolation Level)

  여러 트랜잭션이 동시에 처리 될때, 특정 트랜잭션이 다른 트랜잭션을 변경하거나 조회하는 데이터를 볼수 있게 허용할지의 여부를 결정하는 것.

    - 수준
        - SERIALIZABLE

          가장 엄격한 격리 수준으로, 트랜잭션을 순차적으로 실행시킴. 여러 트랜잭션이 동일한 레코드에 동시 접근이 안되고 이로인해 동시 처리 성능이 매우 떨어진다.

          순수한 SELECT문에서도 대상 레코드에 공유락을 걸어버린다.

          가장 안전하지만 가장 성능이 떨어지기 때문에 극단적인 안전작업이 필요하지 않다면 사용하지 않는것이 좋다.

        - REPEATABLE READ

          MVCC를 통해 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할수 있는 격리수준으로 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된 것만 보도록 하는 것이다.

            - MVCC(Multi-Version Concurrency Control,다중 버전 동시성 제어)

              변경전의 레코드를 UNDO 공간에 백업하여 동일한 레코드에 대해 여러 버전이 존재하는것.  이러한 백업 레코드에는 어느 트랜잭션에 의해 백업이 되었는지 나타내는 트랜잭션 번호를 함께 저장한다.

            - 문제점
                - UPDATE 부정합
                - Phantom Read

                  동일한 트랜잭션에서 동일 쿼리를 두번 실행했는데 첫번째 쿼리에서 없었던 유령 레코드가 나타나는 현상.

        - READ COMMITED

          커밋된 데이터만 조회하도록 하는 격리수준.

            - 문제점
                - Phantom Read
                - Non-Repeatable Read(반복 읽기 불가능)

                  트랜잭션의 commit 시점에 따라서 read의 결과값이 달라지는 문제

        - READ UNCOMMITED

          커밋하지 않은 데이터조차 접근가능 하도록 하는 격리수준, 이로 인해 Dirty Read가 발생한다.  사실상 RDBMS 표준에서 인정하지 않을정도로 정합성에 문제가 많은 격리 수준.

            - Dirty Read

              커밋되지 않은 데이터에 조회를 허용함으로서 변경이 되었을지도 모르는 데이터를 읽어들이는 현상.