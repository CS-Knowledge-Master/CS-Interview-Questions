# TCP 3, 4 way handshake에 대해서 설명해보세요.

## 답변

```
TCP 3, 4 way handshake는 연결 지향 방식인 TCP 프로토콜에서 두 호스트간의 연결을 보장하는 과정에서 진행되는 연결 및 해제과정입니다.
```

### 예상 꼬리질문 및 답변

- TCP 3 way Handshake의 진행 과정에 대해 설명해주세요.
  ```
  TCP 3 way Handshake는 두 호스트간의 TCP 연결을 형성하는 과정입니다.
  우선 클라이언트가 연결하려고 하는 서버에게 SYN 패킷을 전송합니다. 이후 클라이언트는 SYN_SENT 상태로 바뀌게 됩니다.
  서버는 클라이언트가 보낸 SYN 패킷을 받고 클라이언트에게 ACK과 SYN flag가 설정된 패킷을 보내게 됩니다. 이때 서버는 SYN_RECEIVED 상태가 됩니다.
  다시 클라이언트는 이 패킷을 받고 서버에게 ACK을 보내게 됩니다.
  이후 서버가 이 패킷을 받게되면 최종적으로 클라이언트와 서버간의 연결이 형성된것입니다.
  ```
  
- TCP 4 way Handshake의 진행 과정에 대해 설명해주세요.
  ```
  TCP 4 way Handshake는 두 호스트간의 TCP 연결을 해제하는 과정입니다.
  우선 클라이언트가 해제하려고 하는 서버에게 FIN 패킷을 전송합니다. 이후 클라이언트는 FIN_WAIT_1 상태로 바뀌게 됩니다.
  서버는 클라이언트가 보낸 FIN 패킷을 받고 클라이언트에게 ACK 패킷을 보내게 됩니다. 이때 서버는 CLOSE_WAIT 상태가 됩니다.
  그리고 다시 서버가 클라이언트에게 FIN 패킷을 전송합니다. 이때 서버는 LAST_ACK 상태로 바뀌게 됩니다.
  클라이언트는 이 패킷을 받고 서버에게 ACK을 보내게 됩니다. 이때 클라이언트는 TIME_WAIT 상태가 됩니다.
  이후 서버가 이 패킷을 받고 CLOSED 상태로 바뀌며 일정 시간이 지난후 클라이언트도 CLOSED 상태로 바뀌면서 두 호스트간의 연결이 해제가 됩니다.
  ```
  - 왜 서버는 ACK과 FIN을 같이 보내지 않는것인가?
    ```
    이는 서버가 클라이언트에게 보내야할 내용이 남아있을수도 있기에 이를 다 보내고 난후 FIN을 보내는것 입니다.
    ```
  - 왜 클라이언트는 일정 시간후에 CLOSED 상태로 바뀌는가?
    ```
    서버가 FIN 이전에 전송한 패킷이 FIN보다 늦게 도착할수도 있어 문제가 발생할수 있기에 이를 막고자 일정 시간을 둡니다.
    여기서 일정 시간은 보통 패킷이 네트워크에 떠돌수 있는 시간의 2배정도로 세팅을 합니다.
    ```
## 내용 정리

- TCP Handshake

  연결 지향 방식인 TCP 프로토콜에서 두 호스트간의 연결을 보장하는 과정에서 진행되는 연결과 해제과정

    - TCP 3-Way Handshake

      두 호스트간의 통신을 시작하기 전 서로의 연결을 형성하는 과정

        - 진행 과정
            1.  클라이언트 → 서버 (SYN)
                송신자가 TCP Header의 Sequence Number(x)를 임의로 지정하고 SYN flag를 1로 설정하고 보냄
            2. 서버 → 클라이언트 (SYN + ACK)

               서버가 SYN을 받아 클라이언트에게 받았다는 신호로 SYN + ACK 패킷을 보냄

               ACK Number 필드를 x+1로 지정하고 Sequence Number는 임의로 지정한다.(y) SYN flag와 ACK flag를 1로 표시한다.

            3. 클라이언트 → 서버 (ACK)

               클라이언트는 서버의 응답을 받아 ACK을 서버로 보낸다.

               ACK Number 필드를 y+1로 설정.

    - TCP 4-Way Handshake

      통신을 완료한 두 호스트간의 연결을 끊는 과정

        - 진행 과정
            1. 클라이언트 → 서버 (FIN)
               연결을 종료하고자 하는 클라이언트는 서버에서 FIN flag를 세팅후 전송함. 이후 클라이언트는 FIN_WAIT_1 상태로 바뀜.
            2. 서버 → 클라이언트 (ACK)

               FIN을 받은 서버는 CLOSE_WAIT 상태로 변경이되고 받은 FIN에 대한 응답인 ACK을 보내줌.

               ACK을 받은 클라이언트는 FIN_WAIT_2 상태로 바뀌며 SERVER가 보내는 FIN을 기다림

                - 서버가 클라이언트에게 FIN과 같이 ACK을 안보내는 이유

                  서버도 종료를 하기위해 기존에 클라이언트와 작업하던 내용을 마무리해야 하기에 ACK을 작업이 끝나고 보낸다.

                    - 서버가 클라이언트에게 보낼 데이터가 아직 남았을수도 있기에 이를 다보내기 위해 ACK을 같이 안보냄.
            3. 서버 → 클라이언트 (FIN)

               서버가 연결을 종료하기 위해 FIN 패킷을 보냄. 그리고 서버는 LAST_ACK상태로 변경됨.

            4. 클라이언트 → 서버 (ACK)

               FIN을 받은 클라이언트는 TIME_WAIT 상태로 바뀌며 받은 FIN 패킷에 대응하는 ACK을 서버로 보냄.

               이후 서버는 이를 받고 CLOSED상태로 변경됨.

               일정 시간이 지난후 클라이언트도 CLOSED 상태로 변경됨.

               이를 마지막으로 두 호스트간의 연결이 끊어짐.

                - 클라이언트가 TIME_WAIT로 바뀌는 이유

                  서버가 FIN이전에 전송한 패킷이 FIN보다 늦게 와서 발생할수 있는 에러를 방지하기 위함.

                  이때문에 TIME_WAIT 시간은 주로 패킷이 네트워크에 떠돌수 있는 시간에 2배정도로 세팅하게 된다.