# 멀티스레드 프로그래밍에 대해 설명해보세요.

하나의 프로세스에서 여러개의 스레드를 만들어 동시에 여러 작업을 수행하는 것
코어가 아주 짧은 시간동안 여러 작업을 번갈아 수행함으로써 여러 작업들이 모두 동시에 수행되는 것처럼 보이게한다.
---

< 멀티 프로그래밍, 멀티 태스킹, 멀티 쓰레딩, 멀티 프로세싱, 멀티 프로세스 >
* 멀티 프로그래밍

    * 단일 프로세스가 CPU 사용량이 좋지 않다는 점에 착안해 등장

    * 여러 개의 프로그램을 메모리에 올려 놓고 동시에 실행 시키는 원리, I/O 작업이 발생하면 다른 프로세스가 CPU에서 실행된다.

    * CPU 사용량을 극대화 시킴

    * CPU 사용 시간이 길어지면 다른 프로세스는 계속 대기 해야 한다.

*  멀티 태스킹 -> 시분할 시스템
    * 여러 개의 프로그램이 동시에 실행 되는 것처럼 보이게 하는 기법 (cpu 타임을 아주 잘게 쪼갠다) -> 하나의 프로세스가 동시에 여러 작업을 수행하지는 못한다.

    * 프로세스의 응답시간을 최소화 시키는 목적

    * 스레드의 등장으로 프로세스끼리의 아주 짧은 시간의 스위칭에서 프로세스와 스레드가 아주 짧게 쪼개진 cpu 타임을 나누어 가지는 것으로 개념 확장됨
* 멀티 쓰레딩
    * 프로세스의 컨텍스트 스위칭은 오버헤드가 크다.
    * 프로세스끼리의 데이터 공유가 까다롭다.
    * 듀얼 코어가 등장 해서 CPU 의 성능이 병렬 작업이 유리해졌다.

* 멀티 프로세스
    * 여러 개의 프로세스가 서로 협력적으로 일을 처리하는 것
* 멀티 프로세싱
    * 두 개 이상의 프로세서나 코어를 활용하는 시스템

---
< 멀티 쓰레드의 장단점 >
* 장점
1. 컨텍스트 스위칭 시 공유하고 있는 메모리 자원을 아낄 수 있다.
2. 스레드는 프로세스 내의 스택 영역을 제외한 부분을 공유하기 때문에 통신의 오버헤드가 적어 응답시간이 빠르다.

* 단점
1. 스레드 하나가 프로세스 내 자원을 망치면 모든 프로세스가 종료된다.
2. 데이터가 공유되기에 동기화 문제가 있다.

---
<동기화>

여러 프로세스와 스레드를 동시에 실행해도 공유데이터의 일관성을 유지하는 것

<Race condition>

여러 프로세스나 스레드가 동시에 같은 데이터를 조작할 때 타이밍이나 접근 순서에 따라 결과가 달라질 수 있는 상황

<동기화 방법>

멀티코어의 경우 아무리 컨텍스트 스위칭의 순서를 올바르게 하더라도 Race condition 발생가능하다. 따라서 cpu 에서 실행되는 명령어의 묶음이 하나의 스레드에서만 실행할 수 있게 해야한다.

---
<임계영역>

하나의 스레드에서만 메소드를 실행할 수 있게한다.

이처럼 공유데이터의 일관성을 보장하기 위해 하나의 프로세스나 스레드만 진입해 실행가능한 영역이 임계영역이다.

< critical section problem >

임계영역과 관련된 문제 - 공유 변수에 대한 잘못된 접근

<critical section problem 의 해결책이 되기 위한 조건>

1. mutual exclusion - 오직 한 스레드만 진입할 수 있다.
2. progress - 스레드의 진입 유무는 유한 시간 내 결정된다.
3. bounded waiting - 어느스레드든지 유한 시간내에 임계구역에 들어갈 수 있다.

---
< mutual exclusion >

하나의 프로세스, 스레드만 진입해 실행가능한 영역


- 스핀락 - 락을 가질때까지 반복해서 시도

  * TestAndSet - cpu의 atomic 명령어(동시실행불가)

  * 락을 가질때까지 반복해서 시도 - 스핀락 - 락을 기다리는 동안 락 확인 위해 CPU 낭비

  * 컨텍스트 스위칭 발생안함

  * 멀티 코어 환경이고 criticial section 에서의 작업이 컨텍스트 스위칭보다 더 빨리 끝나면 스핀락이 유리

- Mutex - 스핀락 예방

  락을 가질 수 있을 때까지 휴식

  컨텍스트 스위칭 발생

- 세마포

    추후 정리
---
<데드락>

두개 이상의 프로세스 혹은 스레드가 서로가 가진 리소스를 기다리는 상태

1. Mutual exclusion - 리소스(임계영역, 락, 프린트 등등) 공유 불가능
2. Hold and wait - 프로세스가 이미 하나이상의 리소스를 획득한 상태에서 다른 프로세스가 사용하고 있는 리소스를 추가로 기다린다
3. No preemption - 리소스 반환은 오직 그 리소스를 취득한 프로세스만 할 수 있다.
4. Circular wait - 프로세스들이 순환 형태로 서로의 리소스를 기다린다.

---
<os가 데드락을 해결하는 방법>

1. 데드락 방지 - 시스템 레벨에서 디자인
2. 데드락 회피 - 실행환경에서 추가적 정보 활용해 데드락 가능성 회비 - 은행원 알고리즘
3. 데드락 감지와 복구 - 데드락 허용하고 발생시 복구하는 전략
4. 데드락 무시 - 운영체제가 개발자에게 떠넘김
