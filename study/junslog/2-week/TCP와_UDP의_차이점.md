### TCP와 UDP의 차이점에 대해 알려주세요.

TCP는 서버와 클라이언트가 논리적 연결을 수립한 뒤
스트림 기반의 신뢰성있는 데이터를 주고받지만,
UDP는 논리적 연결 없이,
서버에서 일방적으로 다수의 클라이언트에 
데이터그램 기반의 데이터를 전송하는 프로토콜입니다.

---
[ TCP vs UDP : 논리적 연결 여부 ]

### TCP - 서버와 클라이언트의 논리적 연결 수립 과정
- 3-way handshake라고 한다.
< 연결 전 상태 >
- 서버의 웹 서버 프로세스 ( Apache, Nginx )는
포트 번호 80이 바인딩된 socket을 통해 클라이언트의 연결 요청을 받기 위해 대기 한다.
- 클라이언트의 네트워크 연결을 필요로하는 임의의 프로세스가
OS에게 네트워크 연결을 위한 소켓 연결 요청을 한다. ( System Call )
이 때, OS는 임의의 남는 포트 번호를 소켓에 바인딩해서
클라이언트에게 제공한다.
- 클라이언트는 서버의 IP주소와 포트번호를 알고 있다.

< 연결 시도 상태 >
- 클라이언트에서 임의의 Sequence Number를 생성하고,
TCP 헤더의 SYN 비트가 활성화된 패킷에 이를 담아 서버에 보낸다.
( 클라이언트 상태 : SYN_SENT)

- 대기하고 있던 서버는 요청을 받은 뒤,
연결을 수립할 수 있으면 임의의 Sequence Number를 생성한다. 이를 SYN 정보에 넣는다.
그리고, 클라이언트에서 받은 Sequence Number + 1 만큼의 값을 ACK 정보에 넣어 보낸다.
결과적으로 서버는 클라이언트에게 SYN + ACK 비트가 활성화된 패킷을 보낸다.
( 서버 상태 : LISTEN -> SYN_RCVD)

- SYN + ACK 패킷을 받은 클라이언트는 연결 수립 상태가 되고 ( SYN_SENT -> ESTABLISHED )
서버의 연결 요청에 대한 ACK 패킷에 서버가 준 Sequence Number + 1 값을 담아 보낸다.

### TCP 3-way Handshake를 통해 이뤄지는 것들
- Sequence 번호 교환
- 정책 교환 ( MSS = Maximum Segment Size 교환 )
=> 서버와 클라이언트 중 최소 MSS에 전송량을 맞춤. 흐름 제어


### TCP 논리적 연결 종료 과정
- 클라이언트 : 클라이언트의 OS는 App에게 연결 종료 요청을 받는다.
- 클라이언트 : FIN 비트가 활성화된 패킷을 서버에게 보낸다.
- 서버 : 서버의 OS는 FIN 비트가 활성화된 패킷을 받고, ACK 비트가 활성화된 패킷을 클라이언트에게 보낸다.
- 서버 : App에게 연결 종료 요청이 왔음을 알린다.
- 서버 : App으로부터 종료 요청을 받고, FIN 비트가 활성화된 패킷을 클라이언트에게 보낸다.
- 클라이언트 : FIN 패킷을 받고, ACK 요청을 서버로 보낸다.
- 클라이언트 : 전송 지연등 이슈로 아직 못받은 패킷이 있을 수 있으니,
TIME-WAIT 상태로 2 * Maximum Segment Life (MSL) Time 만큼 대기하다 CLOSED 상태가 된다.

### UDP는 클라이언트와 연결을 하지 않음.
- TCP와 다르게 UDP는 연결에 할당되는 논리적 경로가 없음.
- 각각의 패킷이 다른 경로로 전송되고, 독립적 관계를 가진다.
- 흐름 제어(Flow Control)이 없어서 제대로 전송되었는지, 오류가 없는지 확인 불가


<꼬리질문>
- TCP의 흐름 제어는 어떻게 일어나나요?
- 신뢰성있다는 것이 어떤의미일까요?
  - 데이터의 전송 순서 보장
  - 패킷 유실 시 데이터 재전송