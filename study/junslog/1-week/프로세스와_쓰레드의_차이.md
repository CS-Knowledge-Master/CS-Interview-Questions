### 1) 프로세스와 스레드의 차이를 설명해주세요.

[Keyword]

자원 할당 단위 vs 실행 흐름 단위

프로세스 내에서 동시 수행되어야하는 작업의 종류가 늘어남.

- 프로세스 (Process)
    - 운영체제로부터 자원을 할당받은 작업의 단위
- 스레드 (Thread)
    - 프로세스가 할당받은 자원을 사용하는 실행 흐름의 단위

---

**[ 프로그램 vs 프로세스 ]**

- 프로그램은 2차 메모리에 저장되어 있는 코드 덩어리라할 수 있다.
- 프로세스는 프로그램이 실행에 필요한 자원( 메모리, CPU )을 할당받아 실행되는 상태이다.

---

**< 스레드라는 개념은 왜 생겼는가 >**

- 프로그램이 복잡해지면서, 프로그램 내부에서 여러 작업이 동시에 진행되야할 필요성이 생겼다.
- 동일 프로세스를 여러개 할당하는 방법도 있지만, 메모리 낭비 및 프로세스간 데이터 정합성을 위해 공유해야할 데이터가 있는 경우 IPC(Inter Process Communication)를 해야하는데, 이러한 오버헤드 이슈가 있다.

---

**[ 메모리 구조 - 프로세스와 스레드 ]**

프로세스의 메모리 구조

- Code / Text
    - 프로그래머가 작성한 코드가 CPU가 해석 가능한 기계어 형태로 저장되어 있음.
- Data
    - 코드가 실행되며 사용되는 전역 변수, 각종 데이터가 모여있음.
    - .data , .rodata, .bss 영역으로 세분화
        - .data = 전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터 저장
        - .bss = 초기값 없는 전역 변수, static 변수 저장
        - .rodata = const 같은 상수 키워드 선언된 변수나 문자열 상수가 저장
- Stack
    - 호출된 함수가 종료되면 되돌아올 임시 자료 ( ex. 지역 변수 )와 같은 임시적 자료를 저장하는 공간
    - 만약 stack 영역을 초과하면 stack overflow 에러 발생
- Heap
    - 인스턴스와 같은 런타임에 동적으로 할당되는 데이터를 위해 존재하는 공간

Stack과 Heap 영역은 프로세스가 실행되면서 크기가 늘어났다 줄어들기도 하는 동적 영역

---
**< 프로세스와 스레드의 안정성 차이 >**

- 프로세스는 프로세스 간 격리된 공간을 가지고 있기에,
한 프로세스의 장애가 일어나도 다른 프로세스에 영향을 주지 않는다.
그렇기에 좀 더 안정적이다.

- 스레드는 프로세스 내의 메모리를 공유하기에, 스레드 하나에 장애가 나면
다른 스레드들도 모두 종료되는, 안정성이 낮다는 단점이 있다.


---

**<프로세스가 생성되는 것을 운영체제는 어떻게 관리하는가>**

- 운영체제의 내부 프로세스에서 fork() 연산과 exec() 연산을 통해 새 프로세스가 생성된다.
- 운영체제에 의해 프로세스에 메모리가 할당된다. 이 메모리는 code, data, heap, stack 영역으로 이루어져 있다.
- 운영체제 내에 해당 프로세스에 관련한 정보를 관리하는 **PCB(Process Control Block)**가 생긴다.

---

**<스레드는 프로세스와 어떤 자원을 공유하는가>**

- 스레드는 프로세스와 Code, Heap, Data 영역을 공유한다. ( 공유자원 )
- 스레드는 각자만의 실행 시 임시 변수 ( 함수 호출 시 전달되는 인자, 되돌아갈 주소값, 함수 내 선언하는 지역변수 ) 를 저장하기 위한 Stack 메모리를 독립적으로 가진다.

---

< **프로세스간 자원 공유 기법 >**

- 프로세스는 메모리에 별도의 주소 공간에서 실행되기에,

  프로세스간 각자의 변수, 자료구조에 접근할 수 없다.

- 직접적인 접근은 불가능하지만,
  다음과 같은 기법을 사용하여 프로세스간 통신이 가능하다.
    - IPC( Inter-Process Communication )
    - LPC ( Local Inter-Process Communication )
    - 별도의 공유 메모리를 만들어 정보를 주고받는다.
- 프로세스 간 자원 공유는, Context Switching이 필요하기에
  RAM과 CPU 사이의 캐시 메모리까지 초기화되기에, 자원 부담이 크다.

---

< 프로세스 / 스레드의 동시 실행 원리 >

- 멀티 테스팅 기술 때문

CPU의 멀티 코어

- 6코어 12스레드 CPU의 의미는?
    - 논리적인 CPU 반도체 코어가 6개, 논리적인 코어가 12개란 의미.
    - 물리적 코어 하나가 스레드 두 개 이상을 동시 실행 가능하다는 의미, 즉 운영체제가 8개의 작업(task)을 동시에 처리할 수 있다는 의미이다.
    - 이것이 하이퍼스레딩(Hyper-Threading)

요즘 컴퓨팅 환경에서는 수십,수백개의 프로세스가 동작한다.

그러면 12개의 논리적인 스레드로 이것을 어떻게 처리하는가?

→ **병렬성(Parallelism)** 과 **동시성(Concurrency)** 개념을 알아야 한다.

---

CPU의 작업 처리 방식

- 병렬성 ( Parallelism )
    - Fetch - Decode - Execute를 실행하는 여러개의 CPU 코어에 맞춰 여러개의 프로세스, 스레드를 돌려 병렬로 작업들을 동시에 수행하는 것이다.
    - 듀얼코어. 쿼드코어. 옥타코어 등의 명칭이 붙는 멀티코어 프로세서가 달린 컴퓨터에서 할 수 있는 방식
- 동시성 ( Concurrency )
    - 둘 이상의 작업이 동시에 실행되는 것
    - Parallelsim 이 물리적으로 정말 동시에 실행하는 것이라 하면,
      Concurrency는 동시에 실행되는 것처럼 보이게 하는 것이다.
    - 프로세스들을 사람이 인식하지 못할정도의 시간 퀀텀을 두어 Context Switch하며 실행함으로써, 사용자 입장에서 **동시에 실행되는 것처럼** **보이게** 한다.
    - 이렇게 해서, 사용자에게 더 빠른 반응성을 제공한다.

동시성이 필요한 이유

( HW의 물리적 한계 )

- CPU의 발열 등 HW적 이슈로 CPU 클럭을 올리는데에 한계가 있다.
- 그렇다고, 아무리 코어를 많이 넣어도 수십/수백개의 코어를 넣을 수는 없다.
- 즉, 병렬성을 활용하기에는 한계가 있따.

( 논리적 효율 )

- 6코어 12스레드 환경에서, 현재 24개의 작업이 있다고할 때
  12개의 작업은 오래 걸리는 작업이고,
  나머지 12개의 작업은 시간이 얼마 걸리지 않는 작업이라 해보자.
  오래걸리는 작업이 끝이 날 때까지 나머지 12개의 작업이 기다려야하는 경우가 생길 수 있따. 이런 비효울을 극복하기 위해, 작업을 아주 잘게 나누어 번갈아가며 처리하는 동시성 개념이 필요하다.

---

**< OS의 프로세스 스케줄링 >**

- OS에서 CPU를 사용할 수 있는 프로세스를 선택하고, CPU를 할당하는 작업
- 프로세스 스케줄링 알고리즘은
  프로세스의 우선순위, 작업량 등을 고려하여 효율적으로 배치한다.
  이를 통해 OS는 CPU 자우너을 효율적으로 분배하여 시스템의 전반적인 성능을 향상시킨다.
- 운영체제의 특징, 시스템 요구사항에 따라 다양한 알고리즘 방식으로 동작한다.
  : FCFS, SJF, Priority, RR, Multi-Level Queue 등의 알고리즘이 있다.

---

**[ 프로세스 & 스레드의 생명 주기 ]**

< 프로세스의 상태 전이 >

- 프로세스의 상태는 프로세스가 실행되는 동안 변경되는 고유 상태를 의미한다.
- 프로세스가 생성되어 실행하기 까지 프로세스는 여러가지 상태를 가지게 된다.

**[ 프로세스의 상태 ]**

- 생성( new ) : 프로세스가 fork(), exec()을 통해 생성된 후, 아직 준비가 되지 않은 상태 ( Ready Queue에 들어가지 않은 상태 )
- 준비( ready ) : 프로세스가 실행을 위해 기다리는 상태 ( Ready Queue에 들어간 상태 ), CPU를 할당받을 수 있는 상태이고, 언제든지 실행될 준비가 되어있음.
- 실행( running ) : 프로세스가 CPU를 할당받아 실행되는 상태
- 대기( waiting ) : 프로세스가 특정 이벤트 ( Interrupt, System Call.. I/O Request 등 )이 발생하여 대기하는 상태. CPU를 할당받지 못하고. 이벤트가 발생하여 다시 READY 상태로 전환될 때까지 대기한다.
- 종료( terminated ) : 프로세스가 실행을 완료하고 종료된 상태, 더 이상 실행될 수 없으며, 메모리에서 제거된다.

**[ 프로세스 상태 전이 ]**

- 프로세스 상태 전이란,
  프로세스가 실행되는 동안 상태가 OS에 의해 변경되는 것
- OS는 프로세스 스케쥴링 알고리즘에 따라 프로세스의 상태를 변경한다.