### 데이터베이스에서 인덱스를 사용하는 이유 및 장단점

[ 답변의 핵심 포인트 ]
- 검색 속도를 향상
- 삽입, 삭제, 수정 연산이 활발히 일어날 때는 도입에 고려 필요
- 추가적인 메모리 공간 필요, 삽입.삭제.수정 연산 시 오버헤드 발생

데이터베이스에서 인덱스는 테이블 내에서 검색을 빠르게 해야할 때 사용합니다.
데이터에 대한 검색을 빠르게 할 수 있다는 장점이 있지만, ( 특히 존재하지 않는 데이터에 대한 검색이 순차 탐색보다 훨씬 빠르다 )
인덱스를 위한 메모리를 따로 할당해야하고, 테이블 내 데이터의 삽입, 삭제 등 연산이 빈번할 때
인덱스를 새로 구성해줘야하는 오버헤드가 발생할 수 있습니다.

---
### 인덱스에 대한 C.U.D 연산
- 인덱스는 항상 최신 데이터를 정렬된 상태로 유지해야만 한다.
이런 구성임이 보장되어야 원하는 값을 빠르게 탐색 가능하다.

- 인덱스가 적용된 컬럼에 대해
INSERT, UPDATE, DELETE 연산이 수행된다면
각각 다음의 연산을 추가적으로 해주어야 한다.

`INSERT` : 새로운 데이터에 대한 인덱스를 추가한다.
`DELETE` : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행한다.
`UPDATE` : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대한 인덱스를 추가한다.


### 인덱스를 사용하는 경우

[1] 대량의 데이터를 검색하는 경우
- 대량의 데이터를 검색해야 하는 경우, 인덱스를 사용하여 검색 속도를 향상시킬 수 있다.
대량의 데이터를 순차적으로 스캔하는 것은 매우 느리고, 부하가 발생하기에
이 경우 인덱스를 사용하여 검색하는 것이 효율적이다.

[2] 정렬된 결과를 출력하는 경우
- 인덱스는 데이터를 특정 칼럼에 대해 정렬된 상태로 관리한다.
인덱스를 이용해 데이터를 정렬하면, 매우 빠르게 정렬된 결과를 출력할 수 있다.

[3] 조인 연산을 수행하는 경우
- 인덱스를 생성하여 조인 대상의 테이블의 데이터를 빠르게 검색할 수 있기에,
조인 연산 속도를 향상시킬 수 있다.

-> 그렇기에, '외래 키'가 사용되는 열에는 인덱스를 생성해주는 것이 좋다.
또한, JOIN에 자주 사용되는 열에는 인덱스를 생성해주는 것이 좋다.

[4] 유니크한 값을 가져오는 경우
- 인덱스는 유니크한 값을 가지고 있는 필드에 대해 중복되지 않은 값을 빠르게 검색할 수 있다.
이러한 경우, 인덱스를 사용하여 검색 속도를 빠르게 할 수 있다.

[5] 검색 빈도가 높은 경우
- 검색 빈도가 높은 필드에 대해서 인덱스를 생성하여 검색 속도를 향상시키는 것이 좋다.

-> 아래서 나올,
클러스터형 인덱스를 생성할 열은 ( BETWEEN, >, < 등의 조건 )로 사용하거나,
집계 함수를 사용하는 조건이 자주 사용되는 컬럼에 대해 아주 적절하다.
클러스터형 인덱스는 데이터 페이지를 최소로 읽으므로,
조건에서 가장 많이 사용되는 열에 생성하는 것이 바람직하다.
또한, 정렬 조건인 ORDER BY 절에 자주 나오는 열도 클러스터형 인덱스가 유리하다.
클러스터형 인덱스의 데이터 페이지(=리프 페이지)는 이미 정렬되어 있기 때문이다.

### 인덱스 사용에 대해 고려가 필요한 경우

[1] 데이터의 C.U.D 연산이 자주 일어나는 경우
- 인덱스의 상태를 유지하기 위한 연산들로 인해 오버헤드가 발생한다.

[2]


### 인덱스 구현에 사용되는 자료구조

[1] 해시 테이블 ( Hash Table )
- 키(Key)와 해시 값( Hash Value ) 쌍으로 이루어진 자료구조이다.
O(1)의 시간복잡도를 가지고 있어 상당히 빠른 검색을 할 수 있는 것이 특징이다.

- 해시 테이블의 검색 방식은,
키를 해시 함수를 이용하여 해시 값으로 변환한 후,
해당 해시 값에 해당하는 값을 찾아서 검색한다.
검색 속도가 매우 빠르지만, 데이터의 분포에 따라 해시 충돌이 발생할 수 있다.
따라서, 충돌을 해결하기 위한 방법이 필요하다.

- 해시는 등호(=) 연산에만 특화되어 있어,
부등호 연산(>, <)이 자주 사용되는 데이터 검색을 위해서는 해시 테이블은 적합하지 않다.

[2] B-Tree
- B-Tree는 데이터베이스에서 가장 널리 사용되는 인덱스 자료구조 중 하나이다.
O(logN)의 시간 복잡도를 가지고 있다.

- B-Tree는 균형 잡힌 이진 검색 트리로, 데이터베이스에서 검색 속도를 높이기 위해 사용된다.

- B-Tree의 각 노드 내 데이터들은 항상 정렬된 상태이다.
데이터와 데이터 사이의 범위를 이용하여 자식 노드를 가진다. ( 자식 노드의 개수는 n+1 개 이다. )
또한, 한 노드에서 여러 개의 키를 가질 수 있고, 키에 해당하는 데이터도 함께 가지고 있다.

인덱싱은 검색 속도를 높이기 위해 컬럼에 적용한다.
B-Tree ( 추가 삭제 )혹은, B+Tree = 인덱스 검색 속도가 빠르다.
자료구조로 구현되는 것이 일반적이다.

### 인덱스의 종류
- 클러스터형 인덱스, 비클러스터형 인덱스가 있다.

클러스터형 인덱스는 영어사전과 같은 책이고,
비 클러스터형 인덱스는 인덱스가 있는 일반 책과 같다.
즉,

비 클러스터형 인덱스는
인덱스가 별도로 있고, 이 인덱스를 찾은 이후
기재된 해당 페이지로 가야만 실제 내용을 접할 수 있고

클러스터형 인덱스는
영어사전과 같이 책의 내용 자체가 순서대로 정렬이 되어 있어서
인덱스 자체가 책의 내용과 같은 것을 말한다.

클러스터형 인덱스는
테이블당 한 개만 생성할 수 있다.
( 영어사전처럼 오름/내림차순에 따라 정렬이 되므로 )

바 클러스터형 인덱스는
테이블 당 여러개 생성할 수 있다.
클러스터형 인덱스는 행 데이터를 지정한 열에 맞춰서 자동 정렬한다.

테이블의 Primary Key에는 자동으로 클러스터형 인덱스가 생성된다.
기본 키를 지정하는 열에 대해 비클러스터형 인덱스를 생성할 수 있다.
이 경우, 클러스터형 인덱스가 붙은 기본 키 열은 비 클러스터형 인덱스로 바뀐다.

중요한 것은,
'제약조건 없이 테이블 생성 시 인덱스를 만들 수 없고,
인덱스가 자동 생성되기 위한 열의 제약조건은 Primary Key 또는 Unique 뿐이다.'

Primary Key & UNIQUIE 제약조건을 가진 컬럼에 대해서는
클러스터형 / 비클러스터형 인덱스를 자동 생성할 수 있다.
단, 테이블에는 하나의 클러스터형 인덱스만 존재한다.

만약, Primary Key가 A,B 인 테이블이 존재한다면,
A,B인 이름으로 클러스터형 인덱스가 생성된다.
이 때, 무조건적으로 클러스터형 인덱스가 생성되는 것이 아니라,
테이블에 클러스터형 인덱스로 강제 지정된 다른 열이 없는 경우에만 Primary Key가 지정된 열에
클러스터형 인덱스가 생성된다.

---

### 인덱스 내부 작동

!잠깐 용어 정리
: 아래부터 '페이지'라는 용어가 나온다.
B-Tree의 '노드' 용어를 '페이지'라는 8kb 데이터와 동일시 한다.

1) 클러스터형 인덱스
- 클러스터형 인덱스 생성 시에는 데이터 페이지 전체를 다시 정렬한다.

- 이미 대용량의 데이터가 입력된 상태라면, 시스템에 큰 부하를 줄 수 있으므로
업무시간에 클러스터형 인덱스를 생성하는 것은 신중히 검토해야 한다.

- 클러스터형 인덱스는 인덱스 자체의 리프 페이지가 곧 데이터이다.
즉, 영어사전처럼 인덱스 자체에 데이터가 포함되어 있다고 할 수 있다.

- 비 클러스터형 인덱스보다 검색속도는 빠르다.
하지만, 데이터의 입력/수정/삭제는 더 느리다.

- 클러스터형 인덱스는 성능이 좋지만, 테이블에 한 개밖에 생성하지 못한다.
그러므로, 어느 열에 클러스터형 인덱스를 생성하느냐에 따라 시스템의 성능이 달라질 수 있다.

- 클러스터형 인덱스가 테이블에 아예 없는 것이 좋은 경우도 있다.
ex> 회원정보 테이블의 경우
userID 가 Primary Key로 지정되어 클러스터형 인덱스로 설정되어 있다면
회원이 등록될 때마다 즉시 재정렬이 수행되고, 페이지 분할이 끊임없이 일어날 수도 있다.
그런 경우에는, 차라리 클러스터형 인덱스를 비 클러스터형 인덱스로 지정하는 것이 좋다.

2) 비 클러스터형 인덱스
- 비 클러스터형 인덱스의 생성 시에는, 데이터 페이지를 그냥 둔 상태에서
별도의 페이지에 인덱스를 구성한다.

- 비 클러스터형 인덱스는 인덱스 자체의 리프 페이지가 데이터가 아니라,
데이터가 위치하는 포인터(ROW ID)이다.
클러스터형보다 검색속도는 느리지만, 데이터의 입력/수정/삭제는 더 빠르다.

- 비 클러스터형 인덱스는 여러 개 생성할 수 있다.
하지만, 함부로 남용할 경우에는 오히려 시스템의 성능을 떨어트리는 결과를 초래한다.
그렇기에, 꼭 필요한 곳에만 생성해야 한다.

- 포괄열이 있는 비클러스터형 인덱스를 활용하면 쿼리 성능을 높일 수 있다.
'포괄 열이 있는 인덱스' (Index with Included Columns)란
비 클러스터형 인덱스의 리프 페이지에 데이터를 포함하는 열을 말한다.
이를테면, 회원정보 테이블과, 대여정보 테이블이 있는 경우
회원 정보 테이블의 비 클러스터형 인덱스인 회원아이디에 포괄 열 인덱스를 생성하여
대여정보 테이블의 책 이름과 입고일자를 함께 묶어주면
회원 정보 테이블의 userID를 WHERE 절로 검색하였을 경우
그 리프노드에 인덱스로 설정되어 있는 회원Id 뿐만이 아니라, 대여 정보 테이블의 책 이름과 입고 날자도 함께 나타나는 경우를 말한다.

읽어볼만한 블로그 : https://m.blog.naver.com/kimsajang/220805238670