# 데이터베이스 - 트랜잭션의 격리 수준

## 트랜잭션의 격리 수준이란

트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때, 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할 지 여부를 결정하는 것이다.

트랜잭션의 격리 수준을 높은 순서대로 나열하면, `SERIALIZABLE`, `REPEATABLE READ`, `READ COMMITED`, `READ UNCOMMITED` 순이다.

## 먼저 관련 용어를 알아보자.

#### 1.  Dirty Read
> **Dirty Read란**, 동시에 진행되고 있는 다른 트랜잭션(아직 커밋하지 않은 상태)에서 변경한 데이터를 현재 진행 중인 트랜잭션에서 읽어 들이는 것을 뜻한다.

#### 2. Non-Repeatable Read
>**Non-repeatable Read란**, 하나의 트랜잭션 중 읽어 들였던 특정 row의 값을 같은 트랜잭션 내에서 다시 읽어 들이는데 중간에 변경사항이 생겨 (실제로 COMMIT이 된 변경사항) 결괏값이 다르게 나오는 현상을 뜻한다.

#### 3. Phantom Read
>**Phantom read란**, 트랜잭션 시작 시점 데이터를 읽었을 때 존재하지 않았던 데이터가 다시 같은 조건으로 데이터를 읽어 들였을 때 존재해 (유령처럼) 일관적이지 않은 결괏값을 반환하는 현상을 뜻한다.


#### 4. Undo 영역
>**Undo 영역이란**, 트랜잭션 실행 중에 발생하는 변경 사항을 롤백하기 위해 사용되는 공간이다.
여기에는 트랜잭션이 실행되는 동안 수정된 데이터의 이전 버전이 저장되어 있어서 트랜잭션이 롤백되면 데이터를 이전 상태로 되돌릴 수 있다.

- **트랜잭션 롤백**: 트랜잭션이 롤백되면 Undo 영역에 저장된 이전 데이터를 사용하여 변경된 내용을 이전 상태로 되돌린다.

- **MVCC (Multi-Version Concurrency Control)**: 일부 데이터베이스 시스템에서는 여러 버전의 데이터를 동시에 유지하여 서로 다른 트랜잭션 간에 격리 수준을 유지한다.
  이때 Undo 영역은 이전 데이터 버전을 저장하는 데 사용된다.


---
## 트랜잭션 격리 수준(높은순)

### 1. SERIALIZABLE

가장 엄격한 격리 수준이다.
이름 그대로 트랜잭션을 순차적으로 진행시킨다. 즉 여러 트랜잭션이 동일한 레코드에 동시 접근을 할 수 없으므로, 가장 안전한 격리 수준이다.
하지만 동시 처리 성능이 매우 떨어진다.




### 2. REPEATABLE READ

트랜잭션이 시작되기 전에, 커밋이 완료된 내용에 대해서만 조회가 가능하다.
트랜잭션이 완료될 때까지, `SELECT`문이 사용하는 모든 데이터에 `Lock`을 건다.
따라서 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다.
즉, `Non-Repeatable Read`가 발생하지 않는다.

하지만, 일관성을 보장하기 위해 트랜잭션의 실행 시간이 길어질수록 계속 멀티 버전을 관리해야 한다는 단점이 있다.

또한, 중간에 읽지 않은 데이터가 추가되는 경우, `Phantom Read`가 발생할 수 있다.
![](https://akasai.space/static/04b0a47bf579405417bad7ccd4a94e6a/0a47e/phantom-read.png)



### 3. READ COMMITED

한 트랜잭션의 변경 내용이 커밋되어야만 다른 트랜잭션에서 조회가 가능하다.

조회가 이루어지는 동안, `Lock`이 걸린다. 조회를 할 때는 실제 테이블 값이 아니라, `Undo` 영역에 백업된 데이터 값을 가져온다.

하지만 하나의 트랜잭션에서 같은 **SELECT** 쿼리를 실행했을 때는 항상같은 결과를 가져와야 하는 `REPEATABLE READ`의 정합성에 어긋난다.
즉, `Non-Repeatable Read`가 발생한다.

![](https://akasai.space/static/f41b3d2c3a8485ea901630541f413361/af192/read-committed.png)


### 4. READ UNCOMMITED

다른 트랜잭션에 의해 커밋되지 않은 데이터를 읽을 수 있다.

즉, 어떤 트랜잭션의 내용이 **커밋**이나, **롤백**에 상관없이 다른 트랜잭션에 조회가 가능하다.
그렇기 때문에 데이터의 정합성에 많은 문제가 있다.

조회를 하는 동안 해당 데이터에 `Lock`이 걸리지않는다.
그래서 `Dirty Read`가 발생할 수 있다.

![](https://akasai.space/static/b232506d727517ccf4277e8d7fec461b/1bba8/read-uncommitted.png)



![](https://akasai.space/static/a2759879d75d61b7bf6d32d90946883a/0c69d/isolation-level.png)